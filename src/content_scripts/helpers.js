/* global __PRIVACY_MAGIC_INJECT__, __disabledSettings, self */

/** @type { (func: Function, thisArg: any, args: any[]) => any } */
const reflectApply = (func, thisArg, args) => Reflect.apply(func, thisArg, args);

/** @type { (func: Function, thisArg: any, args: any[]) => any } */
export const reflectApplySafe = (func, thisArg, args) => {
  try {
    return reflectApply(func, thisArg, args);
  } catch (error) {
    return undefined;
  }
};

export const objectDefinePropertiesSafe = Object.defineProperties;
const objectGetOwnPropertyDescriptorsSafe = Object.getOwnPropertyDescriptors;

/** @type { <T>(obj: T, propertyMap: { [key: string]: PropertyDescriptor }) => () => void } */
export const redefinePropertiesSafe = (obj, propertyMap) => {
  const originalDescriptors = objectGetOwnPropertyDescriptorsSafe(obj);
  objectDefinePropertiesSafe(obj, propertyMap);
  return () => objectDefinePropertiesSafe(obj, originalDescriptors);
};

/** @type { PropertyDescriptor } */
export const nonProperty = { get: undefined, set: undefined, configurable: true };

/** @type { <T>(obj: T, propertyMap: { [key: string]: any }) => () => void } */
export const redefinePropertyValues = (obj, propertyMap) => {
  /** @type {PropertyDescriptorMap} */
  const originalProperties = {};
  /** @type {PropertyDescriptorMap} */
  const newProperties = {};
  for (const [prop, value] of Object.entries(propertyMap)) {
    const originalDescriptor = Object.getOwnPropertyDescriptor(obj, prop);
    originalProperties[prop] = originalDescriptor || nonProperty;
    if (value === undefined) {
      newProperties[prop] = nonProperty;
    } else {
      if (!originalDescriptor) {
        newProperties[prop] = { configurable: true, get: () => value };
      } else if (originalDescriptor.value) {
        newProperties[prop] = { ...originalDescriptor, value };
      } else {
        newProperties[prop] = { ...originalDescriptor, get: () => value };
      }
    }
  }
  Object.defineProperties(obj, newProperties);
  return () => {
    objectDefinePropertiesSafe(obj, originalProperties);
  };
};

export const createSafeMethod = (globalInterface, methodName) => {
  const originalMethod = Object.getOwnPropertyDescriptor(globalInterface.prototype, methodName).value;
  return (instance, ...args) => reflectApplySafe(originalMethod, instance, args);
};

const weakMapGet = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'get').value;
const weakMapHas = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'has').value;
const weakMapSet = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'set').value;
export const weakMapGetSafe = (weakMap, key) => reflectApplySafe(weakMapGet, weakMap, [key]);
export const weakMapHasSafe = (weakMap, key) => reflectApplySafe(weakMapHas, weakMap, [key]);
export const weakMapSetSafe = (weakMap, key, value) => reflectApplySafe(weakMapSet, weakMap, [key, value]);

export const reflectConstructSafe = Reflect.construct;

export const spoofMediaQuery = (key, spoofValue, targetDefault = false) => {
  const oldMatchMedia = self.matchMedia;
  const targetRegex = new RegExp(`\\(\\s*${key}\\s*:\\s*${spoofValue}\\s*\\)`, 'ig');
  const nonTargetRegex = new RegExp(`\\(\\s*${key}\\s*:\\s*[^)]+\\s*\\)`, 'ig');
  const defaultRegex = new RegExp(`\\(\\s*${key}\\s*\\)`, 'ig');
  const defaultReplacement = targetDefault ? 'all' : 'not all';
  const spoof = (mediaQueryString) =>
    mediaQueryString
      .replace(targetRegex, 'all')
      .replace(nonTargetRegex, 'not all')
      .replace(defaultRegex, defaultReplacement);
  self.matchMedia = (mediaQueryString) => oldMatchMedia(spoof(mediaQueryString));
  return () => {
    self.matchMedia = oldMatchMedia;
  };
};

// Cache the bundle for injection to avoid re-creating it on every call.
let bundleForInjection;

// Makes a code bundle for injection into a sandboxed iframe or a worker. The bundle
// includes the shared secret, the patch decisions, and the __PRIVACY_MAGIC_INJECT__
// wrapper function, which was generated by the rollup intro and outro. (See /rollup.config.js).
export const makeBundleForInjection = (disabledSettings) => {
  if (!bundleForInjection) {
    bundleForInjection = `
  (function () {
    const __PRIVACY_MAGIC_INJECT__ = ${__PRIVACY_MAGIC_INJECT__.toString()};
    __PRIVACY_MAGIC_INJECT__(${JSON.stringify(disabledSettings)});
  })();
    `;
  }
  return bundleForInjection;
};

let trustedTypesPolicy;

export const getTrustedTypesPolicy = () => {
  if (!trustedTypesPolicy) {
    trustedTypesPolicy = self.trustedTypes.createPolicy('sanitized-worker-policy', {
      createHTML: (unsafeHTML) => unsafeHTML,
      createScript: (unsafeScript) => unsafeScript,
      createScriptURL: (unsafeScriptURL) => unsafeScriptURL
    });
  }
  return trustedTypesPolicy;
};

export const getDisabledSettings = (relevantSettings) => {
  if (__disabledSettings !== undefined && Array.isArray(__disabledSettings)) {
    return __disabledSettings;
  }
  let result = [];
  try {
    document.cookie.split(';').forEach(cookie => {
      const [key, value] = cookie.trim().split('=');
      if (key === '__pm__disabled_settings') {
        result = value.split(',');
      }
    });
    document.cookie = '__pm__disabled_settings=; Secure; SameSite=None; Path=/; Partitioned; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
    if (result.length === 1 && result[0] === '') {
      result = [];
    }
    if (relevantSettings) {
      result = result.filter(setting => relevantSettings.includes(setting));
    }
  } catch (error) {
    console.error('error getting disabled settings from cookie:', error);
  }
  // eslint-disable-next-line no-global-assign
  __disabledSettings = result;
  return result;
};
