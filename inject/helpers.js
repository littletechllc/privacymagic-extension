/* global self, __PRIVACY_MAGIC_INJECT__ */

import { getSharedSecret } from './secret.js';

const reflectApply = (...args) => Reflect.apply(...args);

export const reflectApplySafe = (func, thisArg, args) => {
  try {
    return reflectApply(func, thisArg, args);
  } catch (error) {
    return undefined;
  }
};

export const objectDefinePropertiesSafe = Object.defineProperties;
const objectGetOwnPropertyDescriptorsSafe = Object.getOwnPropertyDescriptors;

export const redefinePropertiesSafe = (obj, propertyMap) => {
  const originalDescriptors = objectGetOwnPropertyDescriptorsSafe(obj);
  objectDefinePropertiesSafe(obj, propertyMap);
  return () => objectDefinePropertiesSafe(obj, originalDescriptors);
};

export const nonProperty = { get: undefined, set: undefined, configurable: true };

export const redefinePropertyValues = (obj, propertyMap) => {
  const originalProperties = {};
  const newProperties = {};
  for (const [prop, value] of Object.entries(propertyMap)) {
    const originalDescriptor = Object.getOwnPropertyDescriptor(obj, prop);
    originalProperties[prop] = originalDescriptor || nonProperty;
    if (value === undefined) {
      newProperties[prop] = nonProperty;
    } else {
      if (!originalDescriptor) {
        newProperties[prop] = { configurable: true, get: () => value };
      } else if (originalDescriptor.value) {
        newProperties[prop] = { ...originalDescriptor, value };
      } else {
        newProperties[prop] = { ...originalDescriptor, get: () => value };
      }
    }
  }
  Object.defineProperties(obj, newProperties);
  return () => {
    objectDefinePropertiesSafe(obj, originalProperties);
  };
};

export const createSafeMethod = (globalInterface, methodName) => {
  const originalMethod = Object.getOwnPropertyDescriptor(globalInterface.prototype, methodName).value;
  return (instance, ...args) => reflectApplySafe(originalMethod, instance, args);
};

const weakMapGet = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'get').value;
const weakMapHas = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'has').value;
const weakMapSet = Object.getOwnPropertyDescriptor(WeakMap.prototype, 'set').value;
export const weakMapGetSafe = (weakMap, key) => reflectApplySafe(weakMapGet, weakMap, [key]);
export const weakMapHasSafe = (weakMap, key) => reflectApplySafe(weakMapHas, weakMap, [key]);
export const weakMapSetSafe = (weakMap, key, value) => reflectApplySafe(weakMapSet, weakMap, [key, value]);

export const reflectConstructSafe = Reflect.construct;

// Makes a code bundle for injection into a sandboxed iframe. The bundle includes
// the patch decisions and the __PRIVACY_MAGIC_INJECT__ wrapper function, which was
// generated by the rollup intro and outro. (See /rollup.config.js).
export const makeBundleForInjection = () => `
  self.__existing_secret__ = '${getSharedSecret()}';
  self.__patch_decisions__ = ${JSON.stringify(self.__patch_decisions__)};
  (function () {
    const __PRIVACY_MAGIC_INJECT__ = ${__PRIVACY_MAGIC_INJECT__.toString()};
    __PRIVACY_MAGIC_INJECT__();
  })();
  `;
